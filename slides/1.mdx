<SlidePage>
    
<Cover>

<h1><img src="/ts.png" width="75"/> Typescript</h1>

Why we use it and how you can better understand the benefits

</Cover>

---

## Javascript is squirrelly

It often doesn't work how you think it should

- Lets you do things that don't make much sense
- Doesn't try to help you understand

![x](/umm-what.jpg)

---
## Some examples of said squirrelly-ness
```js
// this is valid
var thing = [] + {};

// this does not throw an error!
thing.tier = 'premium';
thing.size = 150;

console.log(thing.size); // undefined

// 'thing' is a string, imagine that!
console.log(typeof thing); // 'string'
console.log(thing); // '[object Object]'
```

---

![x](/wtf.jpg)

---

## Other Oddities
Can you guess what 'array' + 'array' is? What SHOULD it be?
```js
[] + []
```
<small>hint: it's not like Python which smartly returns []</small>

---


<SpeakerNotes>
Naturally it's `empty string`!
</SpeakerNotes>

```js
[] + [] // ''
```

---

How about 'array' + 'empty object literal'?
```js
[] + {}
```

---

<SpeakerNotes>
(We just saw this one) it's a string too!
</SpeakerNotes>

```js
[] + {} // '[object Object]'
```

---

Surely 'empty object literal' + 'array' is the same as the inverse, right?
```js
{} + []
```
---

<SpeakerNotes>
Nope, that's the number 0
</SpeakerNotes>

```js
{} + [] // 0
```
---

'empty object literal' + 'empty object literal' 
```js
{} + {}
```

<small>This is the only one that's technically correct</small>

---

<SpeakerNotes>
Obviously that's Not a Number!
</SpeakerNotes>

```js
{} + {} // NaN
```

---

You could argue that this is part of what makes JS good
```js
('b' + 'a' + + 'a' + 'a').toLowerCase();
```
<small>please don't ever do this</small>

---
```js
('b' + 'a' + + 'a' + 'a').toLowerCase();
// 'banana'
// also, no errors!
```
![x](/confusing.gif)

---

## The Point: Javascript Is Not Obvious
Some of these examples are a bit contrived, but the point is that it's WAY too easy to make a trivial mistake in our javascript programs.

<SpeakerNotes>
Especially when we're working on a team where our code has many thousands of lines and MUST work reliably for our customers.
</SpeakerNotes>

---

## A real world example
What do you think this function does? Try to figure it out in less than 10 seconds

```js
export function parse(str) {
  const query = {};
  const pairs = (str[0] === '?' ? str.substr(1) : str).split('&');
  pairs.forEach((pair) => {
    const [key, value] = pair.split('=');
    query[decodeURIComponent(key)] = decodeURIComponent(value || '');
  });
  return query;
}
```

<CountDown seconds={10} />

---

>> You spend more time looking at code you _didn't_ write than not, so how can we make that as easy to do as possible?

<img src="/ts-vs-js.jpg" width="550"/>

<SpeakerNotes>
  Ideally, we don't want to have to read every line of code in order to understand the general goal
</SpeakerNotes>

---

## Describe how your code works with types!

<SpeakerNotes>
  Typescript's solution to this problem: Describe how your code works in a way that is human readable and programmatically verifiable
</SpeakerNotes>

---
## So what _is_ a type anyway?
---

### Types are anything that can be differentiated and grouped

<SpeakerNotes>
They serve as a way to specify how something should / can be used and help prevent you from doing things that don't make sense.
</SpeakerNotes>

![](/thinking.jpg)

<small>* in computer code</small>

---

Some examples of types using Typescript

<small>All of the following code is in Typescript</small>

![](/good-better.png)

---

### Primitives are types

```ts
const n: number = 100;
const str: string = 'Hello';
const bool: boolean = true;
const N: bigint = Number.MAX_SAFE_INTEGER + 1n;

n + 1 // 101
str.length // 5
!bool // false

// Error: Type 'string' is not assignable to type 'number'.
n + str

// Error: This condition will always return 'false' since the types 'string' and 'boolean' have no overlap.
str === bool

```

<SpeakerNotes>
  Here we see some primitive data types where each one behaves as we would expect, but with typescript we get some (probably obvious) errors when we attempt to do squirrelly things 
</SpeakerNotes>

---

### Classes are types

```ts
class HttpService {
  get(url: string): Promise<AxiosResponse> {
    return axios.get(url);
  }
}

let someObject: HttpService = new HttpService();

// Error: Type 'URLSearchParams' is not assignable to type 'HttpService'.
// Types of property 'get' are incompatible.
// Type '(name: string) => string | null' is not assignable to type '(url: string) => Promise<AxiosResponse>'.
someObject = new URLSearchParams();

```

<SpeakerNotes>
  Classes are types. Here we declare 'someObject' as the type HttpService and everthing works great, but if we try to assign something else we get a typeError
</SpeakerNotes>

---

## How can we describe types in TS?

1. **`interface`**
2. **`type`**
3. **`inline`**: inline declarations such as:
```ts
const query: Record<string, string> = {};
```

<SpeakerNotes>

- the `interface` keyword describes a contract; How an object should behave and what properties it has available.  
- the `type` keyword is similar to interfaces, but more flexible. You can describe functions, values, and lots of other things

</SpeakerNotes>

---

## Interfaces
`interface`s let you enforce what is allowed without needing special logic to check

<SpeakerNotes>
The Vehicle `interface` is a contract, anything that wants to be a "Vehicle" must implement everything in the interface
</SpeakerNotes>


```ts
interface Vehicle {
  accelerate(magnitude: number): void;
  decelerate(magnitude: number): void;
  start(): void;
  stop(): void;
}

// A valid Vehicle
class Car implements Vehicle {
  private speed: number;
  private isStarted: boolean;

  public accelerate(magnitude: number): void {
    this.speed += magnitude;
  }
  public decelerate(magnitude: number): void {
    this.speed -= magnitude;
  }
  public start(): void {
    this.isStarted = true;
  }
  public stop(): void {
    this.isStarted = false;
  }
}

```
---

## Type
Similar to interfaces, but more flexible.

<SpeakerNotes>
`type` lets you describe objects, functions, values, and lots of other things.
</SpeakerNotes>

```ts
type IQueryParams = Record<string, string | number | boolean | undefined>;

type Modality = 'strength' | 'cycle' | 'run' | 'row';

type Payload = {
  userID: string;
};
```

---

<SpeakerNotes>
Revisiting our example from earlier, how quickly can you figure out what this function does?
</SpeakerNotes>

```ts
type IQueryParams = Record<string, string | number | boolean | undefined>;

export function parseQuery(str: string): IQueryParams {
  // You might not even need to read code sometimes
}

// Argument of type 'number' is not assignable to parameter of type 'string'.
parseQuery(42);

// Argument of type 'string[]' is not assignable to parameter of type 'string'.
parseQuery(['hello!']);

parseQuery('?deviceType=phone&token=AABBCC123&ts=9861243');
// { deviceType: 'phone', token: 'AABBCC123', ts: 9861243 }
```

---

## Inline types

<SpeakerNotes>
  Finally we reach inline types, which are as simple as they sound. Declare your types inline with their use!
</SpeakerNotes>

```ts
function printId(id: number | string) {
  console.log("Your ID is: " + id);
}
// OK
printId(101);
// OK
printId("202");
// Error
printId({ myID: 22342 });
// Argument of type '{ myID: number; }' is not assignable to parameter of type 'string | number'.
// Type '{ myID: number; }' is not assignable to type 'number'.

```

---

## Inferred types
<SpeakerNotes>
Sometimes typescript knows how to understand your code without any extra work on your part.  

Here we create an object literal called `user` and assign a name and age, but on line 4 we try to access an 'id' property that doesn't exist.  

Typescript catches this error for us automatically
</SpeakerNotes>

```ts
const user = { name: 'jack', age: 25 }

// Error
console.log(user.id)
// Property 'id' does not exist on type '{ name: string; age: number; }'.

```

---

## Typescript gives us powerful tools
<SpeakerNotes>
THE POINT: It allows us to describe how we intend our programs to work, and helps guide us when we change things
</SpeakerNotes>

---

## Intellisense
![](/intellisense.gif)

---

## Auto import
![](/auto-import.png)

---

## Refactoring
<img src="/refactor.gif" width="800" />

---

## Things to remember

<small>About Typescript ðŸ˜„</small>

---

![](/ts-runtime.jpg)

---

## Typescript does not change how your code actually executes.

This means you can write your application in a safer way without any performance loss.

```ts
const something: string = 'A STRING';
const transform = (s: string): string => s.toLowerCase();
transform(something);

```

_Results in_

```js
"use strict";
const something = 'A STRING';
const transform = (s) => s.toLowerCase();
transform(something);

```
<small>*There are exceptions to this, but most of the time you won't have to worry about it</small>

---

## `any` is evil
![](/ts-defeat.jpg)

---

`any` is equivalent to driving over a safety barrier, crashing down the mountainside while your car explodes in flames and finally landing in a river where fresh water sharks violently consume you.

![](/this-is-fine.gif)

---

# QA

---

## Thanks! ðŸ¤ 

---

## Resources

- [Gary Bernhardt's wat talk](https://www.destroyallsoftware.com/talks/wat)
- [Typescript docs](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)


</SlidePage>
